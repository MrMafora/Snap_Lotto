# New routes to add to main.py after the cleanup_screenshots function

@app.route('/screenshot-diagnostics')
@login_required
def screenshot_diagnostics():
    """Diagnostic view to identify duplicate screenshots"""
    if not current_user.is_admin:
        flash('You must be an admin to access screenshot diagnostics.', 'danger')
        return redirect(url_for('index'))
    
    try:
        from models import Screenshot
        from puppeteer_service import standardize_lottery_type
        
        # Get all screenshots
        screenshots = Screenshot.query.all()
        
        # Group screenshots by lottery_type first
        screenshots_by_type = {}
        for screenshot in screenshots:
            lottery_type = screenshot.lottery_type
            if lottery_type not in screenshots_by_type:
                screenshots_by_type[lottery_type] = []
            screenshots_by_type[lottery_type].append(screenshot)
            
        # Count duplicate types (multiple URLs for same lottery_type)
        duplicate_types = {}
        for lottery_type, type_screenshots in screenshots_by_type.items():
            if len(type_screenshots) > 1:
                # Get unique URLs for this type
                urls = set(s.url for s in type_screenshots)
                if len(urls) > 1:
                    duplicate_types[lottery_type] = {
                        'count': len(type_screenshots),
                        'urls': list(urls)
                    }
        
        # Check for exact duplicates (same lottery_type AND URL)
        combo_counts = {}
        for screenshot in screenshots:
            combo = (screenshot.lottery_type, screenshot.url)
            if combo not in combo_counts:
                combo_counts[combo] = []
            combo_counts[combo].append(screenshot)
            
        # Find combos with more than one screenshot
        exact_duplicates = {}
        for combo, combo_screenshots in combo_counts.items():
            if len(combo_screenshots) > 1:
                # Sort by timestamp descending
                sorted_screenshots = sorted(combo_screenshots, key=lambda x: x.timestamp, reverse=True)
                exact_duplicates[combo] = {
                    'count': len(sorted_screenshots),
                    'ids': [s.id for s in sorted_screenshots]
                }
        
        # Prepare the summary data
        summary = {
            'total_screenshots': len(screenshots),
            'unique_lottery_types': len(screenshots_by_type),
            'duplicate_type_count': len(duplicate_types),
            'exact_duplicate_count': len(exact_duplicates)
        }
        
        return render_template('screenshot_diagnostics.html', 
                               summary=summary,
                               duplicate_types=duplicate_types,
                               exact_duplicates=exact_duplicates,
                               title='Screenshot Diagnostics')
                               
    except Exception as e:
        app.logger.error(f"Error showing screenshot diagnostics: {str(e)}")
        flash(f"Error showing screenshot diagnostics: {str(e)}", "danger")
        return redirect(url_for('export_screenshots'))

@app.route('/cleanup-duplicates', methods=['POST'])
@login_required
@csrf.exempt
def cleanup_duplicates():
    """Route to cleanup duplicate screenshots using lottery_type+URL combination"""
    if not current_user.is_admin:
        flash('You must be an admin to clean up duplicates.', 'danger')
        return redirect(url_for('index'))
        
    try:
        from models import Screenshot, db
        import os
        
        app.logger.info("Starting duplicate screenshot cleanup")
        
        # Get all screenshots
        all_screenshots = Screenshot.query.all()
        
        # Group by lottery_type+URL combination and keep only the newest
        combo_to_newest = {}
        
        for screenshot in all_screenshots:
            combo_key = (screenshot.lottery_type, screenshot.url)
            if combo_key not in combo_to_newest or screenshot.timestamp > combo_to_newest[combo_key].timestamp:
                combo_to_newest[combo_key] = screenshot
                
        app.logger.info(f"Found {len(combo_to_newest)} unique lottery_type+URL combinations")
        
        # Any screenshot not in combo_to_newest values should be deleted
        screenshots_to_delete = []
        for screenshot in all_screenshots:
            combo_key = (screenshot.lottery_type, screenshot.url)
            if combo_to_newest.get(combo_key) != screenshot:
                screenshots_to_delete.append(screenshot)
                
        app.logger.info(f"Found {len(screenshots_to_delete)} duplicate screenshots to delete")
        
        # Delete files and database records
        deleted_count = 0
        for screenshot in screenshots_to_delete:
            # Try to delete the file if it exists
            if screenshot.path and os.path.exists(screenshot.path):
                try:
                    os.remove(screenshot.path)
                    app.logger.info(f"Deleted file: {screenshot.path}")
                except Exception as file_error:
                    app.logger.warning(f"Could not delete screenshot file {screenshot.path}: {str(file_error)}")
                    
            # Try to delete zoomed file if it exists
            if hasattr(screenshot, 'zoomed_path') and screenshot.zoomed_path and os.path.exists(screenshot.zoomed_path):
                try:
                    os.remove(screenshot.zoomed_path)
                    app.logger.info(f"Deleted zoomed file: {screenshot.zoomed_path}")
                except Exception as file_error:
                    app.logger.warning(f"Could not delete zoomed screenshot file {screenshot.zoomed_path}: {str(file_error)}")
                    
            # Try to delete HTML file if it exists
            if hasattr(screenshot, 'html_path') and screenshot.html_path and os.path.exists(screenshot.html_path):
                try:
                    os.remove(screenshot.html_path)
                    app.logger.info(f"Deleted HTML file: {screenshot.html_path}")
                except Exception as file_error:
                    app.logger.warning(f"Could not delete HTML file {screenshot.html_path}: {str(file_error)}")
            
            # Delete the database record
            db.session.delete(screenshot)
            deleted_count += 1
            
        # Commit all database changes    
        try:
            db.session.commit()
            app.logger.info(f"Successfully deleted {deleted_count} duplicate screenshots")
            flash(f"Successfully deleted {deleted_count} duplicate screenshots.", "success")
        except Exception as db_error:
            db.session.rollback()
            app.logger.error(f"Error committing screenshot deletions: {str(db_error)}")
            flash(f"Error deleting screenshots: {str(db_error)}", "danger")
        
        # Return to the screenshots page, explicitly preventing auto-creation of new screenshots
        # Pass additional query parameter to disable all auto-creation
        response = redirect(url_for('export_screenshots', create_missing='false', strict_cleanup='true'))
        
        # Also set a session cookie to remember that we just did a cleanup
        session['prevent_recreation'] = True
        
        return response
        
    except Exception as e:
        app.logger.error(f"Error cleaning up duplicates: {str(e)}")
        flash(f"Error cleaning up duplicates: {str(e)}", "danger")
        return redirect(url_for('export_screenshots'))